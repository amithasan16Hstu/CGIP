<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Adaptive Histogram Equalization with CLAHE — Optimized Image Contrast</title>
  <style>
    :root{
      --bg:#0a0f1e; --panel:#0f172a; --soft:#111827; --muted:#94a3b8; --fg:#e5e7eb; --brand:#60a5fa; --accent:#a78bfa;
      --ok:#10b981; --warn:#f59e0b; --bad:#ef4444; --grid:#33415555;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial;
      background:radial-gradient(1200px 600px at 20% -10%, #1f2937 0%, transparent 60%),
                 radial-gradient(1200px 600px at 100% 10%, #0b1326 0%, transparent 60%),
                 var(--bg);
      color:var(--fg);
      overflow-x:hidden;
    }
    header{
      position:relative; padding:28px 20px 14px; text-align:center;
    }
    header h1{
      margin:0; font-size: clamp(1.4rem, 2.2vw + 1rem, 2.6rem); letter-spacing:0.4px; font-weight:800;
      background:linear-gradient(90deg,var(--brand),var(--accent)); -webkit-background-clip:text; background-clip:text; color:transparent;
    }
    header p{margin:8px auto 0; color:var(--muted); max-width:900px; font-size:clamp(.9rem, .5vw + .7rem, 1.05rem)}

    .sparkles{position:absolute; inset:0; pointer-events:none; overflow:hidden}
    .sparkles span{position:absolute; width:2px; height:2px; background:rgba(255,255,255,.6); border-radius:50%;
      animation: float 12s linear infinite; opacity:.7}
    @keyframes float{0%{transform:translateY(0)}100%{transform:translateY(120vh)}}

    main{
      display:grid; grid-template-columns: 360px 1fr; gap:18px; padding:16px; max-width:1400px; margin:0 auto;
    }
    @media (max-width: 980px){ main{grid-template-columns:1fr;}}

    .panel{background:linear-gradient(180deg, #0c1224, #0b0f1f 60%); border:1px solid #1f2937; border-radius:18px; box-shadow:0 10px 30px #0006}

    .controls{padding:14px}
    .controls h2{font-size:1rem; margin:0 0 10px; color:#cbd5e1}

    .control{display:grid; grid-template-columns: 130px 1fr; align-items:center; gap:10px; padding:10px 10px; border-radius:12px; transition:background .2s}
    .control:hover{background:#0a142a}
    .control label{color:#94a3b8; font-size:.9rem}
    .control input[type="range"]{width:100%}
    .control input[type="number"]{width:100%; padding:6px 8px; background:#0b1226; border:1px solid #1f2937; color:var(--fg); border-radius:8px}
    .control .inline{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    .control .chip{padding:6px 10px; border-radius:999px; background:#0b1226; border:1px solid #1f2937; cursor:pointer; user-select:none}
    .chip.active{outline:2px solid var(--brand)}

    .btns{display:flex; gap:10px; flex-wrap:wrap; margin:10px 0 6px}
    .btn{padding:10px 14px; border-radius:12px; border:1px solid #1f2937; background:#0b1226; color:var(--fg); cursor:pointer; font-weight:600}
    .btn.primary{background:linear-gradient(135deg, var(--brand), #3b82f6); border-color:#2563eb}
    .btn.ghost{background:transparent}
    .btn:disabled{opacity:.6; cursor:not-allowed}

    .tiny{font-size:.85rem; color:#9ca3af}
    .danger{color:var(--bad)}

    .stats{display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:8px}
    .card{padding:10px; background:#0b1226; border:1px solid #1f2937; border-radius:12px}
    .card h3{margin:0 0 6px; font-size:.9rem; color:#cbd5e1}
    .metric{font-size:1.2rem; font-weight:800}

    .hists{display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:10px}
    .hist{padding:8px; border-radius:12px; background:#0b1226; border:1px solid #1f2937}
    .hist canvas{width:100%; height:120px; display:block}
    .hist .legend{display:flex; justify-content:space-between; font-size:.8rem; color:#9ca3af}

    .preview{position:relative; padding:12px}
    .stage{position:relative; width:100%; aspect-ratio: 16/10; background:#0a142a; border-radius:18px; overflow:hidden; border:1px solid #1f2937}
    .stage canvas{position:absolute; inset:0; width:100%; height:100%; image-rendering:auto}
    .stage .after{clip-path:inset(0 0 0 50%); transition:clip-path .15s}
    .stage .grid-overlay{position:absolute; inset:0; pointer-events:none; background:
      repeating-linear-gradient(to right, transparent 0, transparent calc(var(--tile) - 1px), var(--grid) calc(var(--tile) - 1px), var(--grid) var(--tile)),
      repeating-linear-gradient(to bottom, transparent 0, transparent calc(var(--tile) - 1px), var(--grid) calc(var(--tile) - 1px), var(--grid) var(--tile));
      opacity:.35; mix-blend:screen;}
    .slider-handle{position:absolute; top:0; bottom:0; left:50%; width:3px; background:linear-gradient(180deg, #60a5fa, #a78bfa); box-shadow:0 0 0 2px #0008; cursor:ew-resize}
    .slider-dot{position:absolute; top:50%; left:calc(50% - 10px); width:20px; height:20px; background:#0b1226; border:2px solid #60a5fa; border-radius:50%; transform:translateY(-50%)}

    .processing{position:absolute; inset:0; display:none; align-items:center; justify-content:center; background:#0009; backdrop-filter: blur(2px)}
    .processing.active{display:flex}
    .spinner{border:4px solid #ffffff38; border-top:4px solid #60a5fa; border-radius:50%; width:44px; height:44px; animation:spin 1.1s linear infinite}
    @keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}
    .processing .msg{margin-left:14px; font-weight:700; letter-spacing:.3px}

    .celebrate{position:absolute; inset:0; pointer-events:none; display:none}
    .celebrate.active{display:block}
    .confetti{position:absolute; width:6px; height:10px; background:var(--brand); opacity:.9; transform:translate(-50%, -50%); animation:fall 1.3s ease-out forwards}
    @keyframes fall{0%{transform:translate(var(--x), -10%) rotate(0)} 100%{transform:translate(calc(var(--x) + (var(--dx)*1px)), 110%) rotate(240deg); opacity:0}}

    footer{padding:10px 16px 28px; text-align:center; color:#94a3b8}
    footer a{color:#c4b5fd; text-decoration:none}
  </style>
</head>
<body>
  <header>
    <h1>Adaptive Histogram Equalization with <span title="Contrast Limited AHE">CLAHE</span></h1>
    <p>Upload an image or load a sample, tweak the CLAHE parameters, and compare results with a draggable before/after slider. Fully client‑side. No libraries.</p>
    <div class="sparkles" aria-hidden="true"></div>
  </header>

  <main>
    <section class="panel controls" aria-label="Controls">
      <h2>Controls</h2>
      <div class="btns">
        <input id="file" type="file" accept="image/*" style="display:none" />
        <button class="btn" id="btnUpload">Upload Image</button>
        <button class="btn" id="btnSample">Load Sample</button>
        <button class="btn ghost" id="btnReset" disabled>Reset</button>
        <button class="btn" id="btnDownload" disabled>Download Result</button>
      </div>

      <div class="control">
        <label>Mode</label>
        <div class="inline" id="modeChips">
          <div class="chip active" data-mode="clahe" title="Contrast Limited AHE (recommended)">CLAHE</div>
          <div class="chip" data-mode="ahe" title="Plain AHE (may over‑amplify noise)">AHE</div>
        </div>
      </div>

      <div class="control">
        <label>Clip Limit</label>
        <div class="inline" style="width:100%">
          <input id="clip" type="range" min="0.5" max="6" step="0.1" value="2.5" />
          <input id="clipNum" type="number" min="0.5" max="6" step="0.1" value="2.5" />
        </div>
      </div>

      <div class="control">
        <label>Tile Size (px)</label>
        <div class="inline" style="width:100%">
          <input id="tile" type="range" min="8" max="128" step="4" value="32" />
          <input id="tileNum" type="number" min="8" max="128" step="4" value="32" />
        </div>
      </div>

      <div class="control">
        <label>Bins</label>
        <div class="inline">
          <div class="chip active" data-bins="256">256</div>
          <div class="chip" data-bins="128">128</div>
          <div class="chip" data-bins="64">64</div>
        </div>
      </div>

      <div class="control">
        <label>Color Strategy</label>
        <div class="inline">
          <div class="chip active" data-color="yuv">Y (luma) only</div>
          <div class="chip" data-color="gray">Grayscale</div>
          <div class="chip" data-color="rgb">RGB channels</div>
        </div>
      </div>

      <div class="control">
        <label>Show Grid</label>
        <div class="inline">
          <input id="showGrid" type="checkbox" />
          <span class="tiny">Visualize tiles</span>
        </div>
      </div>

      <div class="control">
        <label>Max Edge (px)</label>
        <div class="inline" style="width:100%">
          <input id="maxEdge" type="range" min="512" max="2000" step="64" value="1200" />
          <input id="maxEdgeNum" type="number" min="512" max="2000" step="64" value="1200" />
        </div>
      </div>

      <div class="stats">
        <div class="card">
          <h3>Luma Std‑Dev (Before)</h3>
          <div class="metric" id="stdBefore">—</div>
        </div>
        <div class="card">
          <h3>Luma Std‑Dev (After)</h3>
          <div class="metric" id="stdAfter">—</div>
        </div>
        <div class="card" style="grid-column:1 / span 2">
          <h3>Contrast Gain</h3>
          <div class="metric" id="gain">—</div>
        </div>
      </div>

      <div class="hists">
        <div class="hist">
          <div class="legend"><span>Histogram — Before</span><span class="tiny">0 → 255</span></div>
          <canvas id="histBefore" width="256" height="120"></canvas>
        </div>
        <div class="hist">
          <div class="legend"><span>Histogram — After</span><span class="tiny">0 → 255</span></div>
          <canvas id="histAfter" width="256" height="120"></canvas>
        </div>
      </div>

      <p class="tiny" style="margin-top:10px">Tip: Lower tile size = more local contrast. Higher clip limit = stronger enhancement. If noise appears, increase tile size or decrease clip limit.</p>
    </section>

    <section class="panel preview" aria-label="Preview">
      <div class="stage" id="stage" style="--tile: 32px">
        <canvas id="canvasBefore" class="before" aria-label="Before"></canvas>
        <canvas id="canvasAfter" class="after" aria-label="After"></canvas>
        <div class="grid-overlay" id="gridOverlay" hidden></div>
        <div class="slider-handle" id="splitBar"></div>
        <div class="slider-dot" id="splitDot"></div>
        <div class="processing" id="processing"><div class="spinner"></div><div class="msg">Equalizing…</div></div>
        <div class="celebrate" id="celebrate"></div>
      </div>
      <div class="btns" style="margin-top:12px">
        <button class="btn primary" id="btnApply" disabled>Apply / Update</button>
        <button class="btn ghost" id="btnToggle" disabled>Toggle View</button>
        <span class="tiny" id="infoWH">—</span>
      </div>
      <p class="tiny" style="margin-top:6px">Drag the vertical bar to compare. “Toggle View” flips before/after sides.</p>
    </section>
  </main>

  <footer>
    © 2025 • Adaptive Histogram Equalization (CLAHE) Demo • <a href="#" id="openHelp">What is CLAHE?</a>
  </footer>

  <dialog id="help" style="max-width:820px; width:95%; background:#0b1226; color:var(--fg); border:1px solid #1f2937; border-radius:16px; padding:14px 16px">
    <h3 style="margin:.2rem 0 0.6rem">Quick explainer</h3>
    <p style="color:#9ca3af; line-height:1.6">Adaptive Histogram Equalization (AHE) improves local contrast by computing a histogram and cumulative distribution (CDF) within small tiles of the image. <b>CLAHE</b> (Contrast‑Limited AHE) caps each histogram bin to a clip limit and redistributes the excess, preventing noise over‑amplification. We then bilinearly interpolate the four surrounding tile mappings per pixel to avoid block artifacts. In this demo, processing can target luminance (Y) in YUV, grayscale, or each RGB channel.</p>
    <form method="dialog" style="text-align:right; margin-top:.6rem">
      <button class="btn">Close</button>
    </form>
  </dialog>

  <script>
  // ------- Sparkles background (subtle) -------
  (function mkSparkles(){
    const box = document.querySelector('.sparkles');
    for(let i=0;i<40;i++){
      const s=document.createElement('span');
      const x=Math.random()*100, delay=Math.random()*-12;
      s.style.left=x+'%'; s.style.top=(Math.random()*100)+'%'; s.style.animationDelay=delay+'s';
      s.style.opacity=0.25+Math.random()*0.4; box.appendChild(s);
    }
  })();

  // ------- DOM refs -------
  const fileInput = document.getElementById('file');
  const btnUpload = document.getElementById('btnUpload');
  const btnSample = document.getElementById('btnSample');
  const btnReset = document.getElementById('btnReset');
  const btnApply = document.getElementById('btnApply');
  const btnToggle = document.getElementById('btnToggle');
  const btnDownload = document.getElementById('btnDownload');
  const stage = document.getElementById('stage');
  const cBefore = document.getElementById('canvasBefore');
  const cAfter  = document.getElementById('canvasAfter');
  const ctxB = cBefore.getContext('2d');
  const ctxA = cAfter.getContext('2d');
  const gridOverlay = document.getElementById('gridOverlay');
  const processing = document.getElementById('processing');
  const celebrate = document.getElementById('celebrate');
  const infoWH = document.getElementById('infoWH');
  const openHelp = document.getElementById('openHelp');
  const helpDlg = document.getElementById('help');

  // Controls
  const modeChips = document.getElementById('modeChips');
  const clip = document.getElementById('clip');
  const clipNum = document.getElementById('clipNum');
  const tile = document.getElementById('tile');
  const tileNum = document.getElementById('tileNum');
  const binsChips = document.querySelectorAll('[data-bins]');
  const colorChips = document.querySelectorAll('[data-color]');
  const showGrid = document.getElementById('showGrid');
  const maxEdge = document.getElementById('maxEdge');
  const maxEdgeNum = document.getElementById('maxEdgeNum');

  const stdBefore = document.getElementById('stdBefore');
  const stdAfter = document.getElementById('stdAfter');
  const gain = document.getElementById('gain');
  const histBefore = document.getElementById('histBefore');
  const histAfter = document.getElementById('histAfter');

  // Slider split UI
  const splitBar = document.getElementById('splitBar');
  const splitDot = document.getElementById('splitDot');
  let split = 0.5; let toggleFlipped=false;

  // State
  const S = {
    img: null, w:0, h:0, scale:1,
    mode: 'clahe',
    clip: 2.5,
    tile: 32,
    bins: 256,
    color: 'yuv', // yuv | gray | rgb
    maxEdge: 1200
  };

  function setActive(group, el){
    group.forEach(x=>x.classList.remove('active'));
    el.classList.add('active');
  }

  // Chip handlers
  modeChips.addEventListener('click', e=>{
    const el=e.target.closest('.chip'); if(!el) return;
    modeChips.querySelectorAll('.chip').forEach(x=>x.classList.remove('active'));
    el.classList.add('active');
    S.mode = el.dataset.mode; scheduleApply();
  });
  binsChips.forEach(ch=>ch.addEventListener('click', e=>{ setActive([...binsChips], ch); S.bins = +ch.dataset.bins; scheduleApply(); }));
  colorChips.forEach(ch=>ch.addEventListener('click', e=>{ setActive([...colorChips], ch); S.color = ch.dataset.color; scheduleApply(); }));

  // Range + number sync
  function syncPair(range, num, key){
    const fn=()=>{ range.value = num.value = clamp(+range.value, +range.min, +range.max); S[key]=+range.value; if(key==='tile'){ stage.style.setProperty('--tile', S.tile+'px'); } scheduleApply(); };
    range.addEventListener('input', ()=>{num.value=range.value});
    num.addEventListener('input', ()=>{range.value=num.value});
    range.addEventListener('change', fn); num.addEventListener('change', fn);
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  syncPair(clip, clipNum, 'clip');
  syncPair(tile, tileNum, 'tile');
  syncPair(maxEdge, maxEdgeNum, 'maxEdge');

  showGrid.addEventListener('change', ()=>{ gridOverlay.hidden = !showGrid.checked; });

  // Upload / Sample
  btnUpload.addEventListener('click', (e)=>{ e.preventDefault(); fileInput.click(); });
  fileInput.addEventListener('change', async()=>{
    if(fileInput.files && fileInput.files[0]){
      const img = await loadImageFromFile(fileInput.files[0]);
      setImage(img);
    }
  });

  btnSample.addEventListener('click', (e)=>{ e.preventDefault(); const img = makeSyntheticSample(1000, 620); setImage(img); });

  btnReset.addEventListener('click', (e)=>{ e.preventDefault(); if(!S.img) return; setImage(S.img, true); });
  btnDownload.addEventListener('click', (e)=>{ e.preventDefault(); if(!S.img) return; const link=document.createElement('a'); link.download='clahe_result.png'; link.href=cAfter.toDataURL('image/png'); link.click(); });
  btnToggle.addEventListener('click', (e)=>{ e.preventDefault(); toggleFlipped = !toggleFlipped; updateSplit(split); });

  openHelp.addEventListener('click', (e)=>{ e.preventDefault(); helpDlg.showModal(); });

  // Slider drag
  function updateSplit(x){
    split = clamp(x,0,1);
    const leftPct = (toggleFlipped? (1-split) : split) * 100;
    cAfter.style.clipPath = `inset(0 0 0 ${leftPct}%)`;
    splitBar.style.left = `calc(${leftPct}% - 1.5px)`;
    splitDot.style.left = `calc(${leftPct}% - 10px)`;
  }
  updateSplit(0.5);

  (function wireDrag(){
    let dragging=false;
    const rect = ()=>stage.getBoundingClientRect();
    function pos(e){ const r=rect(); const x=(e.touches? e.touches[0].clientX: e.clientX) - r.left; return x/ r.width; }
    function down(e){ dragging=true; updateSplit(pos(e)); }
    function move(e){ if(!dragging) return; updateSplit(pos(e)); }
    function up(){ dragging=false; }
    splitBar.addEventListener('mousedown', down);
    stage.addEventListener('mousedown', down);
    window.addEventListener('mousemove', move);
    window.addEventListener('mouseup', up);
    splitBar.addEventListener('touchstart', down, {passive:true});
    window.addEventListener('touchmove', move, {passive:true});
    window.addEventListener('touchend', up);
  })();

  // Processing overlay helpers
  function busy(on){ processing.classList.toggle('active', !!on); }
  function confetti(){
    celebrate.innerHTML='';
    for(let i=0;i<60;i++){
      const d=document.createElement('div'); d.className='confetti';
      d.style.setProperty('--x', (Math.random()*100)+'%');
      d.style.setProperty('--dx', (Math.random()*120-60).toFixed(1));
      d.style.left = (Math.random()*100)+'%'; d.style.top='-4%';
      d.style.background = i%3? '#60a5fa' : (i%2? '#a78bfa' : '#10b981');
      d.style.animationDelay = (Math.random()*0.4)+'s';
      celebrate.appendChild(d);
    }
    celebrate.classList.add('active');
    setTimeout(()=>celebrate.classList.remove('active'), 1500);
  }

  // Image loading & canvas sizing
  function setImage(img, keepParams=false){
    S.img = img; // HTMLImageElement or OffscreenCanvas
    // Compute target size bounded by maxEdge
    const {width:iw, height:ih} = img;
    const me = S.maxEdge;
    const scale = Math.min(1, me/Math.max(iw, ih));
    S.scale = scale; S.w = Math.round(iw*scale); S.h = Math.round(ih*scale);
    resizeCanvases(S.w, S.h);
    ctxB.drawImage(img, 0,0, S.w, S.h);
    ctxA.clearRect(0,0,S.w,S.h);
    infoWH.textContent = `${iw}×${ih} → ${S.w}×${S.h}`;

    btnApply.disabled = false; btnReset.disabled = false; btnToggle.disabled = false; btnDownload.disabled = true;

    if(!keepParams){ /* initial sensible defaults per image */ }
    analyzeAndDrawHist(true); // before only
  }

  function resizeCanvases(w,h){ cBefore.width=w; cBefore.height=h; cAfter.width=w; cAfter.height=h; stage.style.aspectRatio = `${w}/${h}`; }

  async function loadImageFromFile(file){
    return new Promise((res, rej)=>{
      const img = new Image();
      img.onload = ()=>res(img);
      img.onerror = rej;
      img.src = URL.createObjectURL(file);
    });
  }

  // Synthetic low‑contrast sample generator (no external assets)
  function makeSyntheticSample(w,h){
    const cvs=document.createElement('canvas'); cvs.width=w; cvs.height=h; const cx=cvs.getContext('2d');
    // Dark base
    cx.fillStyle='#0a0a0a'; cx.fillRect(0,0,w,h);
    // Low‑contrast gradient vignette
    const g=cx.createRadialGradient(w*0.6,h*0.4, 20, w*0.6,h*0.4, Math.hypot(w,h)*0.7);
    g.addColorStop(0,'#2a2a2a'); g.addColorStop(1,'#0f0f0f'); cx.fillStyle=g; cx.fillRect(0,0,w,h);
    // Soft text & shapes
    cx.fillStyle='rgba(200,200,200,.18)'; cx.font='bold 120px system-ui'; cx.fillText('CLAHE', 40, 200);
    cx.fillStyle='rgba(200,200,200,.10)'; cx.font='600 42px system-ui'; cx.fillText('Adaptive Histogram Equalization', 40, 260);
    // Add faint noise
    const imgData=cx.getImageData(0,0,w,h); const d=imgData.data; for(let i=0;i<d.length;i+=4){ const n=(Math.random()*16-8)|0; d[i]+=n; d[i+1]+=n; d[i+2]+=n; }
    cx.putImageData(imgData,0,0);
    return cvs;
  }

  // Histogram helpers
  function computeHistogramLuma(data){
    const len=data.length/4; const hist=new Uint32Array(256); let sum=0, sum2=0;
    for(let i=0;i<len;i++){
      const idx=i*4; const r=data[idx], g=data[idx+1], b=data[idx+2];
      const y = Math.round(0.299*r + 0.587*g + 0.114*b);
      hist[y]++; sum+=y; sum2+=y*y;
    }
    const mean=sum/len; const variance = sum2/len - mean*mean; const std=Math.sqrt(Math.max(variance,0));
    return {hist, std};
  }

  function drawHistogram(canvas, hist){
    const ctx=canvas.getContext('2d'); const w=canvas.width, h=canvas.height; ctx.clearRect(0,0,w,h);
    const max = Math.max(...hist);
    for(let x=0;x<256;x++){
      const v = hist[x]; const y = h - (max? (v/max)*h : 0);
      ctx.fillStyle = x%2? '#60a5fa' : '#a78bfa';
      ctx.fillRect(x, y, 1, h-y);
    }
  }

  // CLAHE core
  function applyCLAHE(){
    if(!S.img) return;
    busy(true);
    setTimeout(()=>{ // allow spinner paint
      const src = ctxB.getImageData(0,0,S.w,S.h);
      const out = ctxA.createImageData(S.w,S.h);

      if(S.color==='rgb'){
        // Apply per RGB channel (can be edgy). We'll run channel‑wise CLAHE.
        for(let ch=0; ch<3; ch++){
          const mapped = runCLAHEOnChannel(src.data, S.w, S.h, ch);
          for(let i=0;i<mapped.length;i++){ out.data[i*4+ch]=mapped[i]; }
        }
        for(let i=0;i<S.w*S.h;i++) out.data[i*4+3]=255; // alpha
      } else if(S.color==='gray'){
        const y = extractLuma(src.data);
        const y2 = runCLAHE(y, S.w, S.h);
        // write grayscale
        for(let i=0;i<y2.length;i++){ const v=y2[i]; const o=i*4; out.data[o]=v; out.data[o+1]=v; out.data[o+2]=v; out.data[o+3]=255; }
      } else { // yuv
        const {Y,U,V} = rgbToYUV(src.data);
        const Y2 = runCLAHE(Y, S.w, S.h);
        const rgb = yuvToRGB(Y2, U, V);
        out.data.set(rgb);
      }

      ctxA.putImageData(out,0,0);
      analyzeAndDrawHist(false);
      btnDownload.disabled = false;
      busy(false);
      confetti();
    }, 10);
  }

  function runCLAHEOnChannel(rgba, w,h, ch){
    const N=w*h; const arr=new Uint8ClampedArray(N);
    for(let i=0;i<N;i++){ arr[i] = rgba[i*4+ch]; }
    const res = runCLAHE(arr, w,h);
    return res;
  }

  function extractLuma(rgba){
    const N = rgba.length/4; const Y=new Uint8ClampedArray(N);
    for(let i=0;i<N;i++){
      const o=i*4; const r=rgba[o], g=rgba[o+1], b=rgba[o+2];
      Y[i] = Math.round(0.299*r + 0.587*g + 0.114*b);
    }
    return Y;
  }

  function rgbToYUV(rgba){
    const N=rgba.length/4; const Y=new Uint8ClampedArray(N); const U=new Float32Array(N); const V=new Float32Array(N);
    for(let i=0;i<N;i++){
      const o=i*4; const r=rgba[o], g=rgba[o+1], b=rgba[o+2];
      const y = 0.299*r + 0.587*g + 0.114*b;
      const u = -0.14713*r - 0.28886*g + 0.436*b;
      const v =  0.615*r - 0.51499*g - 0.10001*b;
      Y[i]=y; U[i]=u; V[i]=v;
    }
    return {Y,U,V};
  }

  function yuvToRGB(Y, U, V){
    const N=Y.length; const rgba=new Uint8ClampedArray(N*4);
    for(let i=0;i<N;i++){
      const y=Y[i], u=U[i], v=V[i];
      let r = y + 1.13983*v;
      let g = y - 0.39465*u - 0.58060*v;
      let b = y + 2.03211*u;
      const o=i*4; rgba[o]=clamp2(r); rgba[o+1]=clamp2(g); rgba[o+2]=clamp2(b); rgba[o+3]=255;
    }
    return rgba;
  }
  function clamp2(x){ return x<0?0:(x>255?255:x)|0; }

  function runCLAHE(Y, w,h){
    const bins=S.bins; const tileSize=S.tile; const nX = Math.ceil(w/tileSize); const nY = Math.ceil(h/tileSize);
    // Precompute mappings per tile
    const maps = new Array(nX*nY);
    const maxPerBinFactor = (S.mode==='clahe') ? S.clip : Infinity;

    for(let ty=0; ty<nY; ty++){
      const y0 = ty*tileSize; const y1=Math.min(y0+tileSize, h);
      for(let tx=0; tx<nX; tx++){
        const x0 = tx*tileSize; const x1 = Math.min(x0+tileSize, w);
        const idx = ty*nX + tx;
        maps[idx] = buildMapForTile(Y, w,h, x0,y0,x1,y1, bins, maxPerBinFactor);
      }
    }

    // Apply with bilinear interpolation of 4 neighboring maps
    const out = new Uint8ClampedArray(w*h);
    for(let y=0;y<h;y++){
      const ty = Math.floor(y/tileSize); const fy = (y - ty*tileSize)/tileSize; const ty1 = Math.min(ty+1, nY-1);
      for(let x=0;x<w;x++){
        const tx = Math.floor(x/tileSize); const fx = (x - tx*tileSize)/tileSize; const tx1 = Math.min(tx+1, nX-1);
        const tl = maps[ty*nX + tx];
        const tr = maps[ty*nX + tx1];
        const bl = maps[ty1*nX + tx];
        const br = maps[ty1*nX + tx1];
        const v = Y[y*w+x];
        const m00 = tl[v], m10 = tr[v], m01 = bl[v], m11 = br[v];
        const top = m00 + fx*(m10 - m00);
        const bot = m01 + fx*(m11 - m01);
        const val = top + fy*(bot - top);
        out[y*w+x] = val|0;
      }
    }
    return out;
  }

  function buildMapForTile(Y, w,h, x0,y0,x1,y1, bins, clipFactor){
    const hist = new Float64Array(bins); // use float for redistribution
    const area = (x1-x0)*(y1-y0);
    const scale = bins/256; // map 0..255 into bins

    for(let y=y0;y<y1;y++){
      let i=y*w + x0; for(let x=x0;x<x1;x++, i++){
        const v = Y[i];
        const b = Math.min(bins-1, (v*scale)|0);
        hist[b]++;
      }
    }

    // Clip histogram if CLAHE
    if(isFinite(clipFactor)){
      const limit = clipFactor * (area / bins);
      let excess = 0;
      for(let i=0;i<bins;i++){
        if(hist[i] > limit){ excess += (hist[i]-limit); hist[i] = limit; }
      }
      // Redistribute excess uniformly
      const add = Math.floor(excess / bins);
      const rem = Math.floor(excess - add*bins);
      for(let i=0;i<bins;i++) hist[i]+=add;
      for(let i=0;i<rem;i++) hist[i] += 1; // first 'rem' bins get +1
    }

    // CDF -> mapping 0..255
    const cdf = new Float64Array(bins); let run=0; let cdfMin=-1;
    for(let i=0;i<bins;i++){ run+=hist[i]; cdf[i]=run; if(cdfMin<0 && hist[i]>0) cdfMin=cdf[i]; }
    const denom = Math.max(1, area - (cdfMin>0? cdfMin:0));
    const map = new Uint8ClampedArray(256);
    for(let v=0; v<256; v++){
      const b = Math.min(bins-1, (v*scale)|0);
      let m = Math.round( ( (cdf[b] - (cdfMin>0?cdfMin:0)) / denom ) * 255 );
      if(m<0) m=0; else if(m>255) m=255; map[v]=m;
    }
    return map;
  }

  // Analysis + hist drawing
  function analyzeAndDrawHist(beforeOnly){
    const src = ctxB.getImageData(0,0,S.w,S.h);
    const {hist:hB, std:sdB} = computeHistogramLuma(src.data);
    drawHistogram(histBefore, hB);
    stdBefore.textContent = sdB.toFixed(2);

    if(!beforeOnly){
      const out = ctxA.getImageData(0,0,S.w,S.h);
      const {hist:hA, std:sdA} = computeHistogramLuma(out.data);
      drawHistogram(histAfter, hA);
      stdAfter.textContent = sdA.toFixed(2);
      const g = sdB>0? ((sdA - sdB)/sdB*100): 0; gain.textContent = (g>=0? '+':'') + g.toFixed(1) + '%';
    } else {
      // Clear after chart
      const ctx=histAfter.getContext('2d'); ctx.clearRect(0,0,histAfter.width,histAfter.height); stdAfter.textContent='—'; gain.textContent='—';
    }
  }

  // Debounced apply
  let applyTimer=null;
  function scheduleApply(){
    if(!S.img) return;
    clearTimeout(applyTimer);
    applyTimer = setTimeout(()=>applyCLAHE(), 160);
  }

  // Wire Apply button
  btnApply.addEventListener('click', (e)=>{ e.preventDefault(); applyCLAHE(); });

  // Init
  stage.style.setProperty('--tile', S.tile+'px');

  // Show grid overlay if toggled
  const gridObserver = new ResizeObserver(()=>{ gridOverlay.style.setProperty('--tile', S.tile+'px'); });
  gridObserver.observe(stage);

  // Keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if(e.key==='Enter' && !btnApply.disabled){ applyCLAHE(); }
    if(e.key==='g'){ showGrid.checked=!showGrid.checked; gridOverlay.hidden=!showGrid.checked; }
  });

  // First paint with synthetic sample for instant demo
  (function firstBoot(){ const img=makeSyntheticSample(1000,600); setImage(img); })();

  </script>
</body>
</html>
